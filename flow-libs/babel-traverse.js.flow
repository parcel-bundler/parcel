// @flow
declare module "@babel/traverse" {
  import type { Node,
                Function as BabelFunction,
                Class as BabelClass,
                ArrayExpression,
                AssignmentExpression,
                BinaryExpression,
                InterpreterDirective,
                Directive,
                DirectiveLiteral,
                BlockStatement,
                BreakStatement,
                CallExpression,
                CatchClause,
                ConditionalExpression,
                ContinueStatement,
                DebuggerStatement,
                DoWhileStatement,
                EmptyStatement,
                ExpressionStatement,
                File,
                ForInStatement,
                ForStatement,
                FunctionDeclaration,
                FunctionExpression,
                Identifier,
                IfStatement,
                LabeledStatement,
                StringLiteral,
                NumericLiteral,
                NullLiteral,
                BooleanLiteral,
                RegExpLiteral,
                LogicalExpression,
                MemberExpression,
                NewExpression,
                Program,
                ObjectExpression,
                ObjectMethod,
                ObjectProperty,
                RestElement,
                ReturnStatement,
                SequenceExpression,
                ParenthesizedExpression,
                SwitchCase,
                SwitchStatement,
                ThisExpression,
                ThrowStatement,
                TryStatement,
                UnaryExpression,
                UpdateExpression,
                VariableDeclaration,
                VariableDeclarator,
                WhileStatement,
                WithStatement,
                AssignmentPattern,
                ArrayPattern,
                ArrowFunctionExpression,
                ClassBody,
                ClassExpression,
                ClassDeclaration,
                ExportAllDeclaration,
                ExportDefaultDeclaration,
                ExportNamedDeclaration,
                ExportSpecifier,
                ForOfStatement,
                ImportDeclaration,
                ImportDefaultSpecifier,
                ImportNamespaceSpecifier,
                ImportSpecifier,
                MetaProperty,
                ClassMethod,
                ObjectPattern,
                SpreadElement,
                Super,
                TaggedTemplateExpression,
                TemplateElement,
                TemplateLiteral,
                YieldExpression,
                AnyTypeAnnotation,
                ArrayTypeAnnotation,
                BooleanTypeAnnotation,
                BooleanLiteralTypeAnnotation,
                NullLiteralTypeAnnotation,
                ClassImplements,
                DeclareClass,
                DeclareFunction,
                DeclareInterface,
                DeclareModule,
                DeclareModuleExports,
                DeclareTypeAlias,
                DeclareOpaqueType,
                DeclareVariable,
                DeclareExportDeclaration,
                DeclareExportAllDeclaration,
                DeclaredPredicate,
                ExistsTypeAnnotation,
                FunctionTypeAnnotation,
                FunctionTypeParam,
                GenericTypeAnnotation,
                InferredPredicate,
                InterfaceExtends,
                InterfaceDeclaration,
                InterfaceTypeAnnotation,
                IntersectionTypeAnnotation,
                MixedTypeAnnotation,
                EmptyTypeAnnotation,
                NullableTypeAnnotation,
                NumberLiteralTypeAnnotation,
                NumberTypeAnnotation,
                ObjectTypeAnnotation,
                ObjectTypeInternalSlot,
                ObjectTypeCallProperty,
                ObjectTypeIndexer,
                ObjectTypeProperty,
                ObjectTypeSpreadProperty,
                OpaqueType,
                QualifiedTypeIdentifier,
                StringLiteralTypeAnnotation,
                StringTypeAnnotation,
                ThisTypeAnnotation,
                TupleTypeAnnotation,
                TypeofTypeAnnotation,
                TypeAlias,
                TypeAnnotation,
                TypeCastExpression,
                TypeParameter,
                TypeParameterDeclaration,
                TypeParameterInstantiation,
                UnionTypeAnnotation,
                Variance,
                VoidTypeAnnotation,
                EnumDeclaration,
                EnumBooleanBody,
                EnumNumberBody,
                EnumStringBody,
                EnumSymbolBody,
                EnumBooleanMember,
                EnumNumberMember,
                EnumStringMember,
                EnumDefaultedMember,
                JSXAttribute,
                JSXClosingElement,
                JSXElement,
                JSXEmptyExpression,
                JSXExpressionContainer,
                JSXSpreadChild,
                JSXIdentifier,
                JSXMemberExpression,
                JSXNamespacedName,
                JSXOpeningElement,
                JSXSpreadAttribute,
                JSXText,
                JSXFragment,
                JSXOpeningFragment,
                JSXClosingFragment,
                Noop,
                Placeholder,
                V8IntrinsicIdentifier,
                ArgumentPlaceholder,
                AwaitExpression,
                BindExpression,
                ClassProperty,
                OptionalMemberExpression,
                PipelineTopicExpression,
                PipelineBareFunction,
                PipelinePrimaryTopicReference,
                OptionalCallExpression,
                ClassPrivateProperty,
                ClassPrivateMethod,
                Import,
                Decorator,
                DoExpression,
                ExportDefaultSpecifier,
                ExportNamespaceSpecifier,
                PrivateName,
                BigIntLiteral,
                TSParameterProperty,
                TSDeclareFunction,
                TSDeclareMethod,
                TSQualifiedName,
                TSCallSignatureDeclaration,
                TSConstructSignatureDeclaration,
                TSPropertySignature,
                TSMethodSignature,
                TSIndexSignature,
                TSAnyKeyword,
                TSBooleanKeyword,
                TSBigIntKeyword,
                TSNeverKeyword,
                TSNullKeyword,
                TSNumberKeyword,
                TSObjectKeyword,
                TSStringKeyword,
                TSSymbolKeyword,
                TSUndefinedKeyword,
                TSUnknownKeyword,
                TSVoidKeyword,
                TSThisType,
                TSFunctionType,
                TSConstructorType,
                TSTypeReference,
                TSTypePredicate,
                TSTypeQuery,
                TSTypeLiteral,
                TSArrayType,
                TSTupleType,
                TSOptionalType,
                TSRestType,
                TSUnionType,
                TSIntersectionType,
                TSConditionalType,
                TSInferType,
                TSParenthesizedType,
                TSTypeOperator,
                TSIndexedAccessType,
                TSMappedType,
                TSLiteralType,
                TSExpressionWithTypeArguments,
                TSInterfaceDeclaration,
                TSInterfaceBody,
                TSTypeAliasDeclaration,
                TSAsExpression,
                TSTypeAssertion,
                TSEnumDeclaration,
                TSEnumMember,
                TSModuleDeclaration,
                TSModuleBlock,
                TSImportType,
                TSImportEqualsDeclaration,
                TSExternalModuleReference,
                TSNonNullExpression,
                TSExportAssignment,
                TSNamespaceExportDeclaration,
                TSTypeAnnotation,
                TSTypeParameterInstantiation,
                TSTypeParameterDeclaration,
                TSTypeParameter,
                Expression,
                Binary,
                Scopable,
                BlockParent,
                Block,
                Statement,
                Terminatorless,
                CompletionStatement,
                Conditional,
                Loop,
                While,
                ExpressionWrapper,
                For,
                ForXStatement,
                FunctionParent,
                Pureish,
                Declaration,
                PatternLike,
                LVal,
                TSEntityName,
                Literal,
                Immutable,
                UserWhitespacable,
                Method,
                ObjectMember,
                Property,
                UnaryLike,
                Pattern,
                ModuleDeclaration,
                ExportDeclaration,
                ModuleSpecifier,
                Flow,
                FlowType,
                FlowBaseAnnotation,
                FlowDeclaration,
                FlowPredicate,
                EnumBody,
                EnumMember,
                JSX,
                Private,
                TSTypeElement,
                TSType,
                NumberLiteral,
                RegexLiteral,
                RestProperty,
                SpreadProperty } from "@babel/types";

  declare type VariableDeclarationKind =
    | "var"
    | "let"
    | "const"
    | "module"
    | "hoisted";

  declare export interface Binding {
    block: Node;
    path: NodePath<
      | VariableDeclarator
      | ClassDeclaration
      | FunctionDeclaration
      | ModuleSpecifier
    >;
    referencePaths: Array<NodePath<Identifier>>;
    constantViolations: Array<
      NodePath<AssignmentExpression | UpdateExpression>
    >;
    identifier: Identifier;
    scope: Scope;
    kind: VariableDeclarationKind;
    referenced: boolean;
    references: number;
    constant: boolean;
    reference(NodePath<Identifier>): void;
    reassign(NodePath<AssignmentExpression | UpdateExpression>): void;
    dereference(): void;
  }

  declare export interface Scope {
    parent: Scope;
    path: NodePath<Node>;
    references: { [string]: boolean, ... };
    generateUidIdentifier(name?: string): Identifier;
    generateUid(name?: string): string;
    rename(oldName: string, newName?: string): void;

    setData(key: string, value: mixed): void;
    getData(key: string): ?any;
    removeData(key: string): void;

    getBinding(name: string): ?Binding;
    getOwnBinding(name: string): ?Binding;
    getBindingIdentifier(name: string): ?Identifier;
    getOwnBindingIdentifier(name: string): ?Identifier;
    hasOwnBinding(name: string): ?Binding;
    hasBinding(name: string, noGlobals?: boolean): boolean;
    parentHasBinding(name: string, noGlobals?: boolean): boolean;
    removeBinding(name: string): void;

    removeOwnBinding(string): boolean;
    removeBinding(string): boolean;
    registerDeclaration(path: NodePath<Declaration>): void;
    registerBinding(
      kind: VariableDeclarationKind,
      path: NodePath<VariableDeclaration | VariableDeclarator>
    ): void;
    bindings: {[name: string]: Binding, ...};
    getAllBindings(): {[name: string]: Binding, ...};
    getAllBindingsOfKind(...kinds: Array<string>): {[name: string]: Binding, ...};
    push(opts: {|
      id: LVal,
      init?: Expression | null,
      unique?: boolean,
      kind?: VariableDeclarationKind
    |}): void;

    addGlobal(node: Node): void;
    hasGlobal(name: string): boolean;
    hasReference(name: string): boolean;
    isPure(node: Node, constantsOnly?: boolean): boolean;

    crawl(): void;
    getProgramParent(): Scope;
    getFunctionParent(): Scope;
    getBlockParent(): Scope;
  }

  declare export interface NodePath<+T: Node> {
    node: T;
    scope: Scope;
    parent: Node;
    parentPath: NodePath<Node>;
    removed: boolean;
    key: string;
    container: ?NodePath<Node> | Array<NodePath<Node>>;
    get<U: NodePath<Node> | $ReadOnlyArray<NodePath<Node>>>(string): U;
    getStatementParent(): NodePath<Statement>;
    findParent(cb: (NodePath<Node>) => boolean): ?NodePath<Node>;
    find(cb: (NodePath<Node>) => boolean): ?NodePath<Node>;
    getFunctionParent(): NodePath<BabelFunction>;
    getAncestry(): Array<NodePath<Node>>;
    isAncestor(NodePath<Node>): boolean;
    isDescendant(NodePath<Node>): boolean;

    remove(): void;
    replaceWith<U: Node>(U): NodePath<U>;
    replaceWithMultiple<U: Node>(Array<U>): $ReadOnlyArray<NodePath<U>>;
    insertBefore<U: Node>(
      Array<U> | U
    ): $ReadOnlyArray<NodePath<U>>;
    insertAfter<U: Node>(
      Array<U> | U
    ): $ReadOnlyArray<NodePath<U>>;
    unshiftContainer<U: Node>(
      string,
      Array<U> | U
    ): $ReadOnlyArray<NodePath<U>>;
    pushContainer<U: Node>(
      string,
      Array<U> | U
    ): $ReadOnlyArray<NodePath<U>>;
    matchesPattern(
      match: string | Array<string>,
      allowPartial?: boolean
    ): boolean;

    getPrevSibling(): NodePath<Node>;
    getNextSibling(): NodePath<Node>;
    getAllNextSiblings(): $ReadOnlyArray<NodePath<Node>>;
    getAllPrevSiblings(): $ReadOnlyArray<NodePath<Node>>;

    getBindingIdentifiers(
      duplicates?: boolean
    ): { [string]: Identifier, ... };
    getOuterBindingIdentifiers(
      duplicates?: boolean
    ): { [string]: Identifier, ... };
    getBindingIdentifierPaths(
      duplicates?: boolean,
      outer?: boolean
    ): { [string]: NodePath<Identifier>, ... };
    getOuterBindingIdentifierPaths(
      duplicates?: boolean
    ): { [string]: NodePath<Identifier>, ... };

    evaluateTruthy(): ?boolean;
    evaluate(): {| confident: boolean, value: any |};

    arrowFunctionToExpression({|
      allowInsertArrow?: boolean,
      specCompliant?: boolean
    |}): void;
    ensureBlock(): BabelBlockStatement;

    addComment(type: string, content: string, line?: boolean): void;
    addComments(type: string, comments: Array<string>): void;

    setData(string, any): void;
    getData(string): any;

    isPure(): boolean;
    isGenerated(): boolean;
    isUser(): boolean;
    isVar(): boolean;
    isBlockScoped(): boolean;
    isReferenced(): boolean;
    isScope(): boolean;
    isBindingIdentifier(): boolean;
    isReferencedMemberExpression(): boolean;

    traverse<S>(visitor: Visitor<S>, state?: S): void;
    stop(): void;
    skip(): void;
    requeue(pathToQueue?: NodePath<Node>): void;

    isArrayExpression(): boolean;
    isAssignmentExpression(): boolean;
    isBinaryExpression(): boolean;
    isInterpreterDirective(): boolean;
    isDirective(): boolean;
    isDirectiveLiteral(): boolean;
    isBlockStatement(): boolean;
    isBreakStatement(): boolean;
    isCallExpression(): boolean;
    isCatchClause(): boolean;
    isConditionalExpression(): boolean;
    isContinueStatement(): boolean;
    isDebuggerStatement(): boolean;
    isDoWhileStatement(): boolean;
    isEmptyStatement(): boolean;
    isExpressionStatement(): boolean;
    isFile(): boolean;
    isForInStatement(): boolean;
    isForStatement(): boolean;
    isFunctionDeclaration(): boolean;
    isFunctionExpression(): boolean;
    isIdentifier(): boolean;
    isIfStatement(): boolean;
    isLabeledStatement(): boolean;
    isStringLiteral(): boolean;
    isNumericLiteral(): boolean;
    isNullLiteral(): boolean;
    isBooleanLiteral(): boolean;
    isRegExpLiteral(): boolean;
    isLogicalExpression(): boolean;
    isMemberExpression(): boolean;
    isNewExpression(): boolean;
    isProgram(): boolean;
    isObjectExpression(): boolean;
    isObjectMethod(): boolean;
    isObjectProperty(): boolean;
    isRestElement(): boolean;
    isReturnStatement(): boolean;
    isSequenceExpression(): boolean;
    isParenthesizedExpression(): boolean;
    isSwitchCase(): boolean;
    isSwitchStatement(): boolean;
    isThisExpression(): boolean;
    isThrowStatement(): boolean;
    isTryStatement(): boolean;
    isUnaryExpression(): boolean;
    isUpdateExpression(): boolean;
    isVariableDeclaration(): boolean;
    isVariableDeclarator(): boolean;
    isWhileStatement(): boolean;
    isWithStatement(): boolean;
    isAssignmentPattern(): boolean;
    isArrayPattern(): boolean;
    isArrowFunctionExpression(): boolean;
    isClassBody(): boolean;
    isClassExpression(): boolean;
    isClassDeclaration(): boolean;
    isExportAllDeclaration(): boolean;
    isExportDefaultDeclaration(): boolean;
    isExportNamedDeclaration(): boolean;
    isExportSpecifier(): boolean;
    isForOfStatement(): boolean;
    isImportDeclaration(): boolean;
    isImportDefaultSpecifier(): boolean;
    isImportNamespaceSpecifier(): boolean;
    isImportSpecifier(): boolean;
    isMetaProperty(): boolean;
    isClassMethod(): boolean;
    isObjectPattern(): boolean;
    isSpreadElement(): boolean;
    isSuper(): boolean;
    isTaggedTemplateExpression(): boolean;
    isTemplateElement(): boolean;
    isTemplateLiteral(): boolean;
    isYieldExpression(): boolean;
    isAnyTypeAnnotation(): boolean;
    isArrayTypeAnnotation(): boolean;
    isBooleanTypeAnnotation(): boolean;
    isBooleanLiteralTypeAnnotation(): boolean;
    isNullLiteralTypeAnnotation(): boolean;
    isClassImplements(): boolean;
    isDeclareClass(): boolean;
    isDeclareFunction(): boolean;
    isDeclareInterface(): boolean;
    isDeclareModule(): boolean;
    isDeclareModuleExports(): boolean;
    isDeclareTypeAlias(): boolean;
    isDeclareOpaqueType(): boolean;
    isDeclareVariable(): boolean;
    isDeclareExportDeclaration(): boolean;
    isDeclareExportAllDeclaration(): boolean;
    isDeclaredPredicate(): boolean;
    isExistsTypeAnnotation(): boolean;
    isFunctionTypeAnnotation(): boolean;
    isFunctionTypeParam(): boolean;
    isGenericTypeAnnotation(): boolean;
    isInferredPredicate(): boolean;
    isInterfaceExtends(): boolean;
    isInterfaceDeclaration(): boolean;
    isInterfaceTypeAnnotation(): boolean;
    isIntersectionTypeAnnotation(): boolean;
    isMixedTypeAnnotation(): boolean;
    isEmptyTypeAnnotation(): boolean;
    isNullableTypeAnnotation(): boolean;
    isNumberLiteralTypeAnnotation(): boolean;
    isNumberTypeAnnotation(): boolean;
    isObjectTypeAnnotation(): boolean;
    isObjectTypeInternalSlot(): boolean;
    isObjectTypeCallProperty(): boolean;
    isObjectTypeIndexer(): boolean;
    isObjectTypeProperty(): boolean;
    isObjectTypeSpreadProperty(): boolean;
    isOpaqueType(): boolean;
    isQualifiedTypeIdentifier(): boolean;
    isStringLiteralTypeAnnotation(): boolean;
    isStringTypeAnnotation(): boolean;
    isThisTypeAnnotation(): boolean;
    isTupleTypeAnnotation(): boolean;
    isTypeofTypeAnnotation(): boolean;
    isTypeAlias(): boolean;
    isTypeAnnotation(): boolean;
    isTypeCastExpression(): boolean;
    isTypeParameter(): boolean;
    isTypeParameterDeclaration(): boolean;
    isTypeParameterInstantiation(): boolean;
    isUnionTypeAnnotation(): boolean;
    isVariance(): boolean;
    isVoidTypeAnnotation(): boolean;
    isEnumDeclaration(): boolean;
    isEnumBooleanBody(): boolean;
    isEnumNumberBody(): boolean;
    isEnumStringBody(): boolean;
    isEnumSymbolBody(): boolean;
    isEnumBooleanMember(): boolean;
    isEnumNumberMember(): boolean;
    isEnumStringMember(): boolean;
    isEnumDefaultedMember(): boolean;
    isJSXAttribute(): boolean;
    isJSXClosingElement(): boolean;
    isJSXElement(): boolean;
    isJSXEmptyExpression(): boolean;
    isJSXExpressionContainer(): boolean;
    isJSXSpreadChild(): boolean;
    isJSXIdentifier(): boolean;
    isJSXMemberExpression(): boolean;
    isJSXNamespacedName(): boolean;
    isJSXOpeningElement(): boolean;
    isJSXSpreadAttribute(): boolean;
    isJSXText(): boolean;
    isJSXFragment(): boolean;
    isJSXOpeningFragment(): boolean;
    isJSXClosingFragment(): boolean;
    isNoop(): boolean;
    isPlaceholder(): boolean;
    isV8IntrinsicIdentifier(): boolean;
    isArgumentPlaceholder(): boolean;
    isAwaitExpression(): boolean;
    isBindExpression(): boolean;
    isClassProperty(): boolean;
    isOptionalMemberExpression(): boolean;
    isPipelineTopicExpression(): boolean;
    isPipelineBareFunction(): boolean;
    isPipelinePrimaryTopicReference(): boolean;
    isOptionalCallExpression(): boolean;
    isClassPrivateProperty(): boolean;
    isClassPrivateMethod(): boolean;
    isImport(): boolean;
    isDecorator(): boolean;
    isDoExpression(): boolean;
    isExportDefaultSpecifier(): boolean;
    isExportNamespaceSpecifier(): boolean;
    isPrivateName(): boolean;
    isBigIntLiteral(): boolean;
    isTSParameterProperty(): boolean;
    isTSDeclareFunction(): boolean;
    isTSDeclareMethod(): boolean;
    isTSQualifiedName(): boolean;
    isTSCallSignatureDeclaration(): boolean;
    isTSConstructSignatureDeclaration(): boolean;
    isTSPropertySignature(): boolean;
    isTSMethodSignature(): boolean;
    isTSIndexSignature(): boolean;
    isTSAnyKeyword(): boolean;
    isTSBooleanKeyword(): boolean;
    isTSBigIntKeyword(): boolean;
    isTSNeverKeyword(): boolean;
    isTSNullKeyword(): boolean;
    isTSNumberKeyword(): boolean;
    isTSObjectKeyword(): boolean;
    isTSStringKeyword(): boolean;
    isTSSymbolKeyword(): boolean;
    isTSUndefinedKeyword(): boolean;
    isTSUnknownKeyword(): boolean;
    isTSVoidKeyword(): boolean;
    isTSThisType(): boolean;
    isTSFunctionType(): boolean;
    isTSConstructorType(): boolean;
    isTSTypeReference(): boolean;
    isTSTypePredicate(): boolean;
    isTSTypeQuery(): boolean;
    isTSTypeLiteral(): boolean;
    isTSArrayType(): boolean;
    isTSTupleType(): boolean;
    isTSOptionalType(): boolean;
    isTSRestType(): boolean;
    isTSUnionType(): boolean;
    isTSIntersectionType(): boolean;
    isTSConditionalType(): boolean;
    isTSInferType(): boolean;
    isTSParenthesizedType(): boolean;
    isTSTypeOperator(): boolean;
    isTSIndexedAccessType(): boolean;
    isTSMappedType(): boolean;
    isTSLiteralType(): boolean;
    isTSExpressionWithTypeArguments(): boolean;
    isTSInterfaceDeclaration(): boolean;
    isTSInterfaceBody(): boolean;
    isTSTypeAliasDeclaration(): boolean;
    isTSAsExpression(): boolean;
    isTSTypeAssertion(): boolean;
    isTSEnumDeclaration(): boolean;
    isTSEnumMember(): boolean;
    isTSModuleDeclaration(): boolean;
    isTSModuleBlock(): boolean;
    isTSImportType(): boolean;
    isTSImportEqualsDeclaration(): boolean;
    isTSExternalModuleReference(): boolean;
    isTSNonNullExpression(): boolean;
    isTSExportAssignment(): boolean;
    isTSNamespaceExportDeclaration(): boolean;
    isTSTypeAnnotation(): boolean;
    isTSTypeParameterInstantiation(): boolean;
    isTSTypeParameterDeclaration(): boolean;
    isTSTypeParameter(): boolean;
    isExpression(): boolean;
    isBinary(): boolean;
    isScopable(): boolean;
    isBlockParent(): boolean;
    isBlock(): boolean;
    isStatement(): boolean;
    isTerminatorless(): boolean;
    isCompletionStatement(): boolean;
    isConditional(): boolean;
    isLoop(): boolean;
    isWhile(): boolean;
    isExpressionWrapper(): boolean;
    isFor(): boolean;
    isForXStatement(): boolean;
    isFunctionParent(): boolean;
    isPureish(): boolean;
    isDeclaration(): boolean;
    isPatternLike(): boolean;
    isLVal(): boolean;
    isTSEntityName(): boolean;
    isLiteral(): boolean;
    isImmutable(): boolean;
    isUserWhitespacable(): boolean;
    isMethod(): boolean;
    isObjectMember(): boolean;
    isProperty(): boolean;
    isUnaryLike(): boolean;
    isPattern(): boolean;
    isModuleDeclaration(): boolean;
    isExportDeclaration(): boolean;
    isModuleSpecifier(): boolean;
    isFlow(): boolean;
    isFlowType(): boolean;
    isFlowBaseAnnotation(): boolean;
    isFlowDeclaration(): boolean;
    isFlowPredicate(): boolean;
    isEnumBody(): boolean;
    isEnumMember(): boolean;
    isJSX(): boolean;
    isPrivate(): boolean;
    isTSTypeElement(): boolean;
    isTSType(): boolean;
    isNumberLiteral(): boolean;
    isRegexLiteral(): boolean;
    isRestProperty(): boolean;
    isSpreadProperty(): boolean;
  }
  declare export default {|
    <S>(
      node: Node,
      visitor: Visitor<S>,
      scope?: Object,
      state?: S,
      parentPath?: Node
    ): void,
    cache: {|
      clear(): void,
      clearPath(): void,
      clearScope(): void
    |}
  |};

  declare type VisitorFunc<N: Node, S> = (NodePath<N>, S) => void;
  declare type SingleVisitor<N: Node, S> =
    | VisitorFunc<N, S>
    | {|
        enter?: VisitorFunc<N, S>,
        exit?: VisitorFunc<N, S>
      |};

  declare export type Visitor<S> = {
    noScope?: boolean,
    blacklist?: Array<string>,
    shouldSkip?: (NodePath<Node>) => boolean,
    ReferencedIdentifier?: SingleVisitor<Identifier, S>,
    Function?: SingleVisitor<BabelFunction, S>,
    Class?: SingleVisitor<BabelClass, S>,
    ArrayExpression?: SingleVisitor<ArrayExpression, S>,
    AssignmentExpression?: SingleVisitor<AssignmentExpression, S>,
    BinaryExpression?: SingleVisitor<BinaryExpression, S>,
    InterpreterDirective?: SingleVisitor<InterpreterDirective, S>,
    Directive?: SingleVisitor<Directive, S>,
    DirectiveLiteral?: SingleVisitor<DirectiveLiteral, S>,
    BlockStatement?: SingleVisitor<BlockStatement, S>,
    BreakStatement?: SingleVisitor<BreakStatement, S>,
    CallExpression?: SingleVisitor<CallExpression, S>,
    CatchClause?: SingleVisitor<CatchClause, S>,
    ConditionalExpression?: SingleVisitor<ConditionalExpression, S>,
    ContinueStatement?: SingleVisitor<ContinueStatement, S>,
    DebuggerStatement?: SingleVisitor<DebuggerStatement, S>,
    DoWhileStatement?: SingleVisitor<DoWhileStatement, S>,
    EmptyStatement?: SingleVisitor<EmptyStatement, S>,
    ExpressionStatement?: SingleVisitor<ExpressionStatement, S>,
    File?: SingleVisitor<File, S>,
    ForInStatement?: SingleVisitor<ForInStatement, S>,
    ForStatement?: SingleVisitor<ForStatement, S>,
    FunctionDeclaration?: SingleVisitor<FunctionDeclaration, S>,
    FunctionExpression?: SingleVisitor<FunctionExpression, S>,
    Identifier?: SingleVisitor<Identifier, S>,
    IfStatement?: SingleVisitor<IfStatement, S>,
    LabeledStatement?: SingleVisitor<LabeledStatement, S>,
    StringLiteral?: SingleVisitor<StringLiteral, S>,
    NumericLiteral?: SingleVisitor<NumericLiteral, S>,
    NullLiteral?: SingleVisitor<NullLiteral, S>,
    BooleanLiteral?: SingleVisitor<BooleanLiteral, S>,
    RegExpLiteral?: SingleVisitor<RegExpLiteral, S>,
    LogicalExpression?: SingleVisitor<LogicalExpression, S>,
    MemberExpression?: SingleVisitor<MemberExpression, S>,
    NewExpression?: SingleVisitor<NewExpression, S>,
    Program?: SingleVisitor<Program, S>,
    ObjectExpression?: SingleVisitor<ObjectExpression, S>,
    ObjectMethod?: SingleVisitor<ObjectMethod, S>,
    ObjectProperty?: SingleVisitor<ObjectProperty, S>,
    RestElement?: SingleVisitor<RestElement, S>,
    ReturnStatement?: SingleVisitor<ReturnStatement, S>,
    SequenceExpression?: SingleVisitor<SequenceExpression, S>,
    ParenthesizedExpression?: SingleVisitor<ParenthesizedExpression, S>,
    SwitchCase?: SingleVisitor<SwitchCase, S>,
    SwitchStatement?: SingleVisitor<SwitchStatement, S>,
    ThisExpression?: SingleVisitor<ThisExpression, S>,
    ThrowStatement?: SingleVisitor<ThrowStatement, S>,
    TryStatement?: SingleVisitor<TryStatement, S>,
    UnaryExpression?: SingleVisitor<UnaryExpression, S>,
    UpdateExpression?: SingleVisitor<UpdateExpression, S>,
    VariableDeclaration?: SingleVisitor<VariableDeclaration, S>,
    VariableDeclarator?: SingleVisitor<VariableDeclarator, S>,
    WhileStatement?: SingleVisitor<WhileStatement, S>,
    WithStatement?: SingleVisitor<WithStatement, S>,
    AssignmentPattern?: SingleVisitor<AssignmentPattern, S>,
    ArrayPattern?: SingleVisitor<ArrayPattern, S>,
    ArrowFunctionExpression?: SingleVisitor<ArrowFunctionExpression, S>,
    ClassBody?: SingleVisitor<ClassBody, S>,
    ClassExpression?: SingleVisitor<ClassExpression, S>,
    ClassDeclaration?: SingleVisitor<ClassDeclaration, S>,
    ExportAllDeclaration?: SingleVisitor<ExportAllDeclaration, S>,
    ExportDefaultDeclaration?: SingleVisitor<ExportDefaultDeclaration, S>,
    ExportNamedDeclaration?: SingleVisitor<ExportNamedDeclaration, S>,
    ExportSpecifier?: SingleVisitor<ExportSpecifier, S>,
    ForOfStatement?: SingleVisitor<ForOfStatement, S>,
    ImportDeclaration?: SingleVisitor<ImportDeclaration, S>,
    ImportDefaultSpecifier?: SingleVisitor<ImportDefaultSpecifier, S>,
    ImportNamespaceSpecifier?: SingleVisitor<ImportNamespaceSpecifier, S>,
    ImportSpecifier?: SingleVisitor<ImportSpecifier, S>,
    MetaProperty?: SingleVisitor<MetaProperty, S>,
    ClassMethod?: SingleVisitor<ClassMethod, S>,
    ObjectPattern?: SingleVisitor<ObjectPattern, S>,
    SpreadElement?: SingleVisitor<SpreadElement, S>,
    Super?: SingleVisitor<Super, S>,
    TaggedTemplateExpression?: SingleVisitor<TaggedTemplateExpression, S>,
    TemplateElement?: SingleVisitor<TemplateElement, S>,
    TemplateLiteral?: SingleVisitor<TemplateLiteral, S>,
    YieldExpression?: SingleVisitor<YieldExpression, S>,
    AnyTypeAnnotation?: SingleVisitor<AnyTypeAnnotation, S>,
    ArrayTypeAnnotation?: SingleVisitor<ArrayTypeAnnotation, S>,
    BooleanTypeAnnotation?: SingleVisitor<BooleanTypeAnnotation, S>,
    BooleanLiteralTypeAnnotation?: SingleVisitor<BooleanLiteralTypeAnnotation, S>,
    NullLiteralTypeAnnotation?: SingleVisitor<NullLiteralTypeAnnotation, S>,
    ClassImplements?: SingleVisitor<ClassImplements, S>,
    DeclareClass?: SingleVisitor<DeclareClass, S>,
    DeclareFunction?: SingleVisitor<DeclareFunction, S>,
    DeclareInterface?: SingleVisitor<DeclareInterface, S>,
    DeclareModule?: SingleVisitor<DeclareModule, S>,
    DeclareModuleExports?: SingleVisitor<DeclareModuleExports, S>,
    DeclareTypeAlias?: SingleVisitor<DeclareTypeAlias, S>,
    DeclareOpaqueType?: SingleVisitor<DeclareOpaqueType, S>,
    DeclareVariable?: SingleVisitor<DeclareVariable, S>,
    DeclareExportDeclaration?: SingleVisitor<DeclareExportDeclaration, S>,
    DeclareExportAllDeclaration?: SingleVisitor<DeclareExportAllDeclaration, S>,
    DeclaredPredicate?: SingleVisitor<DeclaredPredicate, S>,
    ExistsTypeAnnotation?: SingleVisitor<ExistsTypeAnnotation, S>,
    FunctionTypeAnnotation?: SingleVisitor<FunctionTypeAnnotation, S>,
    FunctionTypeParam?: SingleVisitor<FunctionTypeParam, S>,
    GenericTypeAnnotation?: SingleVisitor<GenericTypeAnnotation, S>,
    InferredPredicate?: SingleVisitor<InferredPredicate, S>,
    InterfaceExtends?: SingleVisitor<InterfaceExtends, S>,
    InterfaceDeclaration?: SingleVisitor<InterfaceDeclaration, S>,
    InterfaceTypeAnnotation?: SingleVisitor<InterfaceTypeAnnotation, S>,
    IntersectionTypeAnnotation?: SingleVisitor<IntersectionTypeAnnotation, S>,
    MixedTypeAnnotation?: SingleVisitor<MixedTypeAnnotation, S>,
    EmptyTypeAnnotation?: SingleVisitor<EmptyTypeAnnotation, S>,
    NullableTypeAnnotation?: SingleVisitor<NullableTypeAnnotation, S>,
    NumberLiteralTypeAnnotation?: SingleVisitor<NumberLiteralTypeAnnotation, S>,
    NumberTypeAnnotation?: SingleVisitor<NumberTypeAnnotation, S>,
    ObjectTypeAnnotation?: SingleVisitor<ObjectTypeAnnotation, S>,
    ObjectTypeInternalSlot?: SingleVisitor<ObjectTypeInternalSlot, S>,
    ObjectTypeCallProperty?: SingleVisitor<ObjectTypeCallProperty, S>,
    ObjectTypeIndexer?: SingleVisitor<ObjectTypeIndexer, S>,
    ObjectTypeProperty?: SingleVisitor<ObjectTypeProperty, S>,
    ObjectTypeSpreadProperty?: SingleVisitor<ObjectTypeSpreadProperty, S>,
    OpaqueType?: SingleVisitor<OpaqueType, S>,
    QualifiedTypeIdentifier?: SingleVisitor<QualifiedTypeIdentifier, S>,
    StringLiteralTypeAnnotation?: SingleVisitor<StringLiteralTypeAnnotation, S>,
    StringTypeAnnotation?: SingleVisitor<StringTypeAnnotation, S>,
    ThisTypeAnnotation?: SingleVisitor<ThisTypeAnnotation, S>,
    TupleTypeAnnotation?: SingleVisitor<TupleTypeAnnotation, S>,
    TypeofTypeAnnotation?: SingleVisitor<TypeofTypeAnnotation, S>,
    TypeAlias?: SingleVisitor<TypeAlias, S>,
    TypeAnnotation?: SingleVisitor<TypeAnnotation, S>,
    TypeCastExpression?: SingleVisitor<TypeCastExpression, S>,
    TypeParameter?: SingleVisitor<TypeParameter, S>,
    TypeParameterDeclaration?: SingleVisitor<TypeParameterDeclaration, S>,
    TypeParameterInstantiation?: SingleVisitor<TypeParameterInstantiation, S>,
    UnionTypeAnnotation?: SingleVisitor<UnionTypeAnnotation, S>,
    Variance?: SingleVisitor<Variance, S>,
    VoidTypeAnnotation?: SingleVisitor<VoidTypeAnnotation, S>,
    EnumDeclaration?: SingleVisitor<EnumDeclaration, S>,
    EnumBooleanBody?: SingleVisitor<EnumBooleanBody, S>,
    EnumNumberBody?: SingleVisitor<EnumNumberBody, S>,
    EnumStringBody?: SingleVisitor<EnumStringBody, S>,
    EnumSymbolBody?: SingleVisitor<EnumSymbolBody, S>,
    EnumBooleanMember?: SingleVisitor<EnumBooleanMember, S>,
    EnumNumberMember?: SingleVisitor<EnumNumberMember, S>,
    EnumStringMember?: SingleVisitor<EnumStringMember, S>,
    EnumDefaultedMember?: SingleVisitor<EnumDefaultedMember, S>,
    JSXAttribute?: SingleVisitor<JSXAttribute, S>,
    JSXClosingElement?: SingleVisitor<JSXClosingElement, S>,
    JSXElement?: SingleVisitor<JSXElement, S>,
    JSXEmptyExpression?: SingleVisitor<JSXEmptyExpression, S>,
    JSXExpressionContainer?: SingleVisitor<JSXExpressionContainer, S>,
    JSXSpreadChild?: SingleVisitor<JSXSpreadChild, S>,
    JSXIdentifier?: SingleVisitor<JSXIdentifier, S>,
    JSXMemberExpression?: SingleVisitor<JSXMemberExpression, S>,
    JSXNamespacedName?: SingleVisitor<JSXNamespacedName, S>,
    JSXOpeningElement?: SingleVisitor<JSXOpeningElement, S>,
    JSXSpreadAttribute?: SingleVisitor<JSXSpreadAttribute, S>,
    JSXText?: SingleVisitor<JSXText, S>,
    JSXFragment?: SingleVisitor<JSXFragment, S>,
    JSXOpeningFragment?: SingleVisitor<JSXOpeningFragment, S>,
    JSXClosingFragment?: SingleVisitor<JSXClosingFragment, S>,
    Noop?: SingleVisitor<Noop, S>,
    Placeholder?: SingleVisitor<Placeholder, S>,
    V8IntrinsicIdentifier?: SingleVisitor<V8IntrinsicIdentifier, S>,
    ArgumentPlaceholder?: SingleVisitor<ArgumentPlaceholder, S>,
    AwaitExpression?: SingleVisitor<AwaitExpression, S>,
    BindExpression?: SingleVisitor<BindExpression, S>,
    ClassProperty?: SingleVisitor<ClassProperty, S>,
    OptionalMemberExpression?: SingleVisitor<OptionalMemberExpression, S>,
    PipelineTopicExpression?: SingleVisitor<PipelineTopicExpression, S>,
    PipelineBareFunction?: SingleVisitor<PipelineBareFunction, S>,
    PipelinePrimaryTopicReference?: SingleVisitor<PipelinePrimaryTopicReference, S>,
    OptionalCallExpression?: SingleVisitor<OptionalCallExpression, S>,
    ClassPrivateProperty?: SingleVisitor<ClassPrivateProperty, S>,
    ClassPrivateMethod?: SingleVisitor<ClassPrivateMethod, S>,
    Import?: SingleVisitor<Import, S>,
    Decorator?: SingleVisitor<Decorator, S>,
    DoExpression?: SingleVisitor<DoExpression, S>,
    ExportDefaultSpecifier?: SingleVisitor<ExportDefaultSpecifier, S>,
    ExportNamespaceSpecifier?: SingleVisitor<ExportNamespaceSpecifier, S>,
    PrivateName?: SingleVisitor<PrivateName, S>,
    BigIntLiteral?: SingleVisitor<BigIntLiteral, S>,
    TSParameterProperty?: SingleVisitor<TSParameterProperty, S>,
    TSDeclareFunction?: SingleVisitor<TSDeclareFunction, S>,
    TSDeclareMethod?: SingleVisitor<TSDeclareMethod, S>,
    TSQualifiedName?: SingleVisitor<TSQualifiedName, S>,
    TSCallSignatureDeclaration?: SingleVisitor<TSCallSignatureDeclaration, S>,
    TSConstructSignatureDeclaration?: SingleVisitor<TSConstructSignatureDeclaration, S>,
    TSPropertySignature?: SingleVisitor<TSPropertySignature, S>,
    TSMethodSignature?: SingleVisitor<TSMethodSignature, S>,
    TSIndexSignature?: SingleVisitor<TSIndexSignature, S>,
    TSAnyKeyword?: SingleVisitor<TSAnyKeyword, S>,
    TSBooleanKeyword?: SingleVisitor<TSBooleanKeyword, S>,
    TSBigIntKeyword?: SingleVisitor<TSBigIntKeyword, S>,
    TSNeverKeyword?: SingleVisitor<TSNeverKeyword, S>,
    TSNullKeyword?: SingleVisitor<TSNullKeyword, S>,
    TSNumberKeyword?: SingleVisitor<TSNumberKeyword, S>,
    TSObjectKeyword?: SingleVisitor<TSObjectKeyword, S>,
    TSStringKeyword?: SingleVisitor<TSStringKeyword, S>,
    TSSymbolKeyword?: SingleVisitor<TSSymbolKeyword, S>,
    TSUndefinedKeyword?: SingleVisitor<TSUndefinedKeyword, S>,
    TSUnknownKeyword?: SingleVisitor<TSUnknownKeyword, S>,
    TSVoidKeyword?: SingleVisitor<TSVoidKeyword, S>,
    TSThisType?: SingleVisitor<TSThisType, S>,
    TSFunctionType?: SingleVisitor<TSFunctionType, S>,
    TSConstructorType?: SingleVisitor<TSConstructorType, S>,
    TSTypeReference?: SingleVisitor<TSTypeReference, S>,
    TSTypePredicate?: SingleVisitor<TSTypePredicate, S>,
    TSTypeQuery?: SingleVisitor<TSTypeQuery, S>,
    TSTypeLiteral?: SingleVisitor<TSTypeLiteral, S>,
    TSArrayType?: SingleVisitor<TSArrayType, S>,
    TSTupleType?: SingleVisitor<TSTupleType, S>,
    TSOptionalType?: SingleVisitor<TSOptionalType, S>,
    TSRestType?: SingleVisitor<TSRestType, S>,
    TSUnionType?: SingleVisitor<TSUnionType, S>,
    TSIntersectionType?: SingleVisitor<TSIntersectionType, S>,
    TSConditionalType?: SingleVisitor<TSConditionalType, S>,
    TSInferType?: SingleVisitor<TSInferType, S>,
    TSParenthesizedType?: SingleVisitor<TSParenthesizedType, S>,
    TSTypeOperator?: SingleVisitor<TSTypeOperator, S>,
    TSIndexedAccessType?: SingleVisitor<TSIndexedAccessType, S>,
    TSMappedType?: SingleVisitor<TSMappedType, S>,
    TSLiteralType?: SingleVisitor<TSLiteralType, S>,
    TSExpressionWithTypeArguments?: SingleVisitor<TSExpressionWithTypeArguments, S>,
    TSInterfaceDeclaration?: SingleVisitor<TSInterfaceDeclaration, S>,
    TSInterfaceBody?: SingleVisitor<TSInterfaceBody, S>,
    TSTypeAliasDeclaration?: SingleVisitor<TSTypeAliasDeclaration, S>,
    TSAsExpression?: SingleVisitor<TSAsExpression, S>,
    TSTypeAssertion?: SingleVisitor<TSTypeAssertion, S>,
    TSEnumDeclaration?: SingleVisitor<TSEnumDeclaration, S>,
    TSEnumMember?: SingleVisitor<TSEnumMember, S>,
    TSModuleDeclaration?: SingleVisitor<TSModuleDeclaration, S>,
    TSModuleBlock?: SingleVisitor<TSModuleBlock, S>,
    TSImportType?: SingleVisitor<TSImportType, S>,
    TSImportEqualsDeclaration?: SingleVisitor<TSImportEqualsDeclaration, S>,
    TSExternalModuleReference?: SingleVisitor<TSExternalModuleReference, S>,
    TSNonNullExpression?: SingleVisitor<TSNonNullExpression, S>,
    TSExportAssignment?: SingleVisitor<TSExportAssignment, S>,
    TSNamespaceExportDeclaration?: SingleVisitor<TSNamespaceExportDeclaration, S>,
    TSTypeAnnotation?: SingleVisitor<TSTypeAnnotation, S>,
    TSTypeParameterInstantiation?: SingleVisitor<TSTypeParameterInstantiation, S>,
    TSTypeParameterDeclaration?: SingleVisitor<TSTypeParameterDeclaration, S>,
    TSTypeParameter?: SingleVisitor<TSTypeParameter, S>,
    Expression?: SingleVisitor<Expression, S>,
    Binary?: SingleVisitor<Binary, S>,
    Scopable?: SingleVisitor<Scopable, S>,
    BlockParent?: SingleVisitor<BlockParent, S>,
    Block?: SingleVisitor<Block, S>,
    Statement?: SingleVisitor<Statement, S>,
    Terminatorless?: SingleVisitor<Terminatorless, S>,
    CompletionStatement?: SingleVisitor<CompletionStatement, S>,
    Conditional?: SingleVisitor<Conditional, S>,
    Loop?: SingleVisitor<Loop, S>,
    While?: SingleVisitor<While, S>,
    ExpressionWrapper?: SingleVisitor<ExpressionWrapper, S>,
    For?: SingleVisitor<For, S>,
    ForXStatement?: SingleVisitor<ForXStatement, S>,
    FunctionParent?: SingleVisitor<FunctionParent, S>,
    Pureish?: SingleVisitor<Pureish, S>,
    Declaration?: SingleVisitor<Declaration, S>,
    PatternLike?: SingleVisitor<PatternLike, S>,
    LVal?: SingleVisitor<LVal, S>,
    TSEntityName?: SingleVisitor<TSEntityName, S>,
    Literal?: SingleVisitor<Literal, S>,
    Immutable?: SingleVisitor<Immutable, S>,
    UserWhitespacable?: SingleVisitor<UserWhitespacable, S>,
    Method?: SingleVisitor<Method, S>,
    ObjectMember?: SingleVisitor<ObjectMember, S>,
    Property?: SingleVisitor<Property, S>,
    UnaryLike?: SingleVisitor<UnaryLike, S>,
    Pattern?: SingleVisitor<Pattern, S>,
    ModuleDeclaration?: SingleVisitor<ModuleDeclaration, S>,
    ExportDeclaration?: SingleVisitor<ExportDeclaration, S>,
    ModuleSpecifier?: SingleVisitor<ModuleSpecifier, S>,
    Flow?: SingleVisitor<Flow, S>,
    FlowType?: SingleVisitor<FlowType, S>,
    FlowBaseAnnotation?: SingleVisitor<FlowBaseAnnotation, S>,
    FlowDeclaration?: SingleVisitor<FlowDeclaration, S>,
    FlowPredicate?: SingleVisitor<FlowPredicate, S>,
    EnumBody?: SingleVisitor<EnumBody, S>,
    EnumMember?: SingleVisitor<EnumMember, S>,
    JSX?: SingleVisitor<JSX, S>,
    Private?: SingleVisitor<Private, S>,
    TSTypeElement?: SingleVisitor<TSTypeElement, S>,
    TSType?: SingleVisitor<TSType, S>,
    NumberLiteral?: SingleVisitor<NumberLiteral, S>,
    RegexLiteral?: SingleVisitor<RegexLiteral, S>,
    RestProperty?: SingleVisitor<RestProperty, S>,
    SpreadProperty?: SingleVisitor<SpreadProperty, S>,
    [string]: SingleVisitor<Node, S>,
    ...
  };
}
